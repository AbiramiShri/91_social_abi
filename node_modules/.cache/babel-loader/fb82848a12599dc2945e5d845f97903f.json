{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathFindingLinkFactory = void 0;\n\nconst React = require(\"react\");\n\nconst PathFindingLinkModel_1 = require(\"./PathFindingLinkModel\");\n\nconst PathFindingLinkWidget_1 = require(\"./PathFindingLinkWidget\");\n\nconst _ = require(\"lodash\");\n\nconst Path = require(\"paths-js/path\");\n\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\n\nconst react_canvas_core_1 = require(\"@projectstorm/react-canvas-core\");\n\nlet PathFindingLinkFactory =\n/** @class */\n(() => {\n  class PathFindingLinkFactory extends react_diagrams_defaults_1.DefaultLinkFactory {\n    constructor() {\n      super(PathFindingLinkFactory.NAME);\n      this.ROUTING_SCALING_FACTOR = 5; // calculated only when smart routing is active\n\n      this.canvasMatrix = [];\n      this.routingMatrix = []; // used when at least one element has negative coordinates\n\n      this.hAdjustmentFactor = 0;\n      this.vAdjustmentFactor = 0;\n      /**\n       * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n       * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n       */\n\n      this.calculateMatrixDimensions = () => {\n        const allNodesCoords = _.values(this.engine.getModel().getNodes()).map(item => ({\n          x: item.getX(),\n          width: item.width,\n          y: item.getY(),\n          height: item.height\n        }));\n\n        const allLinks = _.values(this.engine.getModel().getLinks());\n\n        const allPortsCoords = _.flatMap(allLinks.map(link => [link.getSourcePort(), link.getTargetPort()])).filter(port => port !== null).map(item => ({\n          x: item.getX(),\n          width: item.width,\n          y: item.getY(),\n          height: item.height\n        }));\n\n        const allPointsCoords = _.flatMap(allLinks.map(link => link.getPoints())).map(item => ({\n          // points don't have width/height, so let's just use 0\n          x: item.getX(),\n          width: 0,\n          y: item.getY(),\n          height: 0\n        }));\n\n        const sumProps = (object, props) => _.reduce(props, (acc, prop) => acc + _.get(object, prop, 0), 0);\n\n        const canvas = this.engine.getCanvas();\n\n        const concatedCoords = _.concat(allNodesCoords, allPortsCoords, allPointsCoords);\n\n        const minX = Math.floor(Math.min(_.get(_.minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n\n        const maxXElement = _.maxBy(concatedCoords, item => sumProps(item, ['x', 'width']));\n\n        const maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n\n        const minYCoords = _.minBy(concatedCoords, 'y');\n\n        const minY = Math.floor(Math.min(_.get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n\n        const maxYElement = _.maxBy(concatedCoords, item => sumProps(item, ['y', 'height']));\n\n        const maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n        return {\n          width: Math.ceil(Math.abs(minX) + maxX),\n          hAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n          height: Math.ceil(Math.abs(minY) + maxY),\n          vAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n        };\n      };\n      /**\n       * Updates (by reference) where nodes will be drawn on the matrix passed in.\n       */\n\n\n      this.markNodes = matrix => {\n        _.values(this.engine.getModel().getNodes()).forEach(node => {\n          const startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n          const endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n          const startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n          const endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n\n          for (let x = startX - 1; x <= endX + 1; x++) {\n            for (let y = startY - 1; y < endY + 1; y++) {\n              this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n            }\n          }\n        });\n      };\n      /**\n       * Updates (by reference) where ports will be drawn on the matrix passed in.\n       */\n\n\n      this.markPorts = matrix => {\n        const allElements = _.flatMap(_.values(this.engine.getModel().getLinks()).map(link => [].concat(link.getSourcePort(), link.getTargetPort())));\n\n        allElements.filter(port => port !== null).forEach(port => {\n          const startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n          const endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n          const startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n          const endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n\n          for (let x = startX - 1; x <= endX + 1; x++) {\n            for (let y = startY - 1; y < endY + 1; y++) {\n              this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n            }\n          }\n        });\n      };\n\n      this.markMatrixPoint = (matrix, x, y) => {\n        if (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n          matrix[y][x] = 1;\n        }\n      };\n    }\n\n    setDiagramEngine(engine) {\n      super.setDiagramEngine(engine); // listen for drag changes\n\n      engine.getStateMachine().registerListener({\n        stateChanged: event => {\n          if (event.newState instanceof react_canvas_core_1.AbstractDisplacementState) {\n            const deRegister = engine.getActionEventBus().registerAction(new react_canvas_core_1.Action({\n              type: react_canvas_core_1.InputType.MOUSE_UP,\n              fire: () => {\n                this.calculateRoutingMatrix();\n                engine.repaintCanvas();\n                deRegister();\n              }\n            }));\n          }\n        }\n      });\n      this.listener = engine.registerListener({\n        canvasReady: () => {\n          _.defer(() => {\n            this.calculateRoutingMatrix();\n            engine.repaintCanvas();\n          });\n        }\n      });\n    }\n\n    setFactoryBank(bank) {\n      super.setFactoryBank(bank);\n\n      if (!bank && this.listener) {\n        this.listener.deregister();\n      }\n    }\n\n    generateReactWidget(event) {\n      return React.createElement(PathFindingLinkWidget_1.PathFindingLinkWidget, {\n        diagramEngine: this.engine,\n        link: event.model,\n        factory: this\n      });\n    }\n\n    generateModel(event) {\n      return new PathFindingLinkModel_1.PathFindingLinkModel();\n    }\n    /**\n     * A representation of the canvas in the following format:\n     *\n     * +-----------------+\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * | 0 0 0 0 0 0 0 0 |\n     * +-----------------+\n     *\n     * In which all walkable points are marked by zeros.\n     * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n     */\n\n\n    getCanvasMatrix() {\n      if (this.canvasMatrix.length === 0) {\n        this.calculateCanvasMatrix();\n      }\n\n      return this.canvasMatrix;\n    }\n\n    calculateCanvasMatrix() {\n      const {\n        width: canvasWidth,\n        hAdjustmentFactor,\n        height: canvasHeight,\n        vAdjustmentFactor\n      } = this.calculateMatrixDimensions();\n      this.hAdjustmentFactor = hAdjustmentFactor;\n      this.vAdjustmentFactor = vAdjustmentFactor;\n      const matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n      const matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n      this.canvasMatrix = _.range(0, matrixHeight).map(() => {\n        return new Array(matrixWidth).fill(0);\n      });\n    }\n    /**\n     * A representation of the canvas in the following format:\n     *\n     * +-----------------+\n     * | 0 0 1 1 0 0 0 0 |\n     * | 0 0 1 1 0 0 1 1 |\n     * | 0 0 0 0 0 0 1 1 |\n     * | 1 1 0 0 0 0 0 0 |\n     * | 1 1 0 0 0 0 0 0 |\n     * +-----------------+\n     *\n     * In which all points blocked by a node (and its ports) are\n     * marked as 1; points were there is nothing (ie, free) receive 0.\n     */\n\n\n    getRoutingMatrix() {\n      if (this.routingMatrix.length === 0) {\n        this.calculateRoutingMatrix();\n      }\n\n      return this.routingMatrix;\n    }\n\n    calculateRoutingMatrix() {\n      const matrix = _.cloneDeep(this.getCanvasMatrix()); // nodes need to be marked as blocked points\n\n\n      this.markNodes(matrix); // same thing for ports\n\n      this.markPorts(matrix);\n      this.routingMatrix = matrix;\n    }\n    /**\n     * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n     * We use the functions below to translate back and forth between these coordinates, relying on the\n     * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n     */\n\n\n    translateRoutingX(x, reverse = false) {\n      return x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n    }\n\n    translateRoutingY(y, reverse = false) {\n      return y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n    }\n\n    generateDynamicPath(pathCoords) {\n      let path = Path();\n      path = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n      pathCoords.slice(1).forEach(coords => {\n        path = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n      });\n      return path.print();\n    }\n\n  }\n\n  PathFindingLinkFactory.NAME = 'pathfinding';\n  return PathFindingLinkFactory;\n})();\n\nexports.PathFindingLinkFactory = PathFindingLinkFactory;","map":{"version":3,"sources":["../../../src/link/PathFindingLinkFactory.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathFindingLinkFactory = void 0;\nconst React = require(\"react\");\nconst PathFindingLinkModel_1 = require(\"./PathFindingLinkModel\");\nconst PathFindingLinkWidget_1 = require(\"./PathFindingLinkWidget\");\nconst _ = require(\"lodash\");\nconst Path = require(\"paths-js/path\");\nconst react_diagrams_defaults_1 = require(\"@projectstorm/react-diagrams-defaults\");\nconst react_canvas_core_1 = require(\"@projectstorm/react-canvas-core\");\nlet PathFindingLinkFactory = /** @class */ (() => {\n    class PathFindingLinkFactory extends react_diagrams_defaults_1.DefaultLinkFactory {\n        constructor() {\n            super(PathFindingLinkFactory.NAME);\n            this.ROUTING_SCALING_FACTOR = 5;\n            // calculated only when smart routing is active\n            this.canvasMatrix = [];\n            this.routingMatrix = [];\n            // used when at least one element has negative coordinates\n            this.hAdjustmentFactor = 0;\n            this.vAdjustmentFactor = 0;\n            /**\n             * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n             * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n             */\n            this.calculateMatrixDimensions = () => {\n                const allNodesCoords = _.values(this.engine.getModel().getNodes()).map((item) => ({\n                    x: item.getX(),\n                    width: item.width,\n                    y: item.getY(),\n                    height: item.height\n                }));\n                const allLinks = _.values(this.engine.getModel().getLinks());\n                const allPortsCoords = _.flatMap(allLinks.map((link) => [link.getSourcePort(), link.getTargetPort()]))\n                    .filter((port) => port !== null)\n                    .map((item) => ({\n                    x: item.getX(),\n                    width: item.width,\n                    y: item.getY(),\n                    height: item.height\n                }));\n                const allPointsCoords = _.flatMap(allLinks.map((link) => link.getPoints())).map((item) => ({\n                    // points don't have width/height, so let's just use 0\n                    x: item.getX(),\n                    width: 0,\n                    y: item.getY(),\n                    height: 0\n                }));\n                const sumProps = (object, props) => _.reduce(props, (acc, prop) => acc + _.get(object, prop, 0), 0);\n                const canvas = this.engine.getCanvas();\n                const concatedCoords = _.concat(allNodesCoords, allPortsCoords, allPointsCoords);\n                const minX = Math.floor(Math.min(_.get(_.minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) *\n                    this.ROUTING_SCALING_FACTOR;\n                const maxXElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['x', 'width']));\n                const maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n                const minYCoords = _.minBy(concatedCoords, 'y');\n                const minY = Math.floor(Math.min(_.get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n                const maxYElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['y', 'height']));\n                const maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n                return {\n                    width: Math.ceil(Math.abs(minX) + maxX),\n                    hAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n                    height: Math.ceil(Math.abs(minY) + maxY),\n                    vAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n                };\n            };\n            /**\n             * Updates (by reference) where nodes will be drawn on the matrix passed in.\n             */\n            this.markNodes = (matrix) => {\n                _.values(this.engine.getModel().getNodes()).forEach((node) => {\n                    const startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n                    const endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n                    const startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n                    const endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n                    for (let x = startX - 1; x <= endX + 1; x++) {\n                        for (let y = startY - 1; y < endY + 1; y++) {\n                            this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n                        }\n                    }\n                });\n            };\n            /**\n             * Updates (by reference) where ports will be drawn on the matrix passed in.\n             */\n            this.markPorts = (matrix) => {\n                const allElements = _.flatMap(_.values(this.engine.getModel().getLinks()).map((link) => [].concat(link.getSourcePort(), link.getTargetPort())));\n                allElements\n                    .filter((port) => port !== null)\n                    .forEach((port) => {\n                    const startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n                    const endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n                    const startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n                    const endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n                    for (let x = startX - 1; x <= endX + 1; x++) {\n                        for (let y = startY - 1; y < endY + 1; y++) {\n                            this.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n                        }\n                    }\n                });\n            };\n            this.markMatrixPoint = (matrix, x, y) => {\n                if (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n                    matrix[y][x] = 1;\n                }\n            };\n        }\n        setDiagramEngine(engine) {\n            super.setDiagramEngine(engine);\n            // listen for drag changes\n            engine.getStateMachine().registerListener({\n                stateChanged: (event) => {\n                    if (event.newState instanceof react_canvas_core_1.AbstractDisplacementState) {\n                        const deRegister = engine.getActionEventBus().registerAction(new react_canvas_core_1.Action({\n                            type: react_canvas_core_1.InputType.MOUSE_UP,\n                            fire: () => {\n                                this.calculateRoutingMatrix();\n                                engine.repaintCanvas();\n                                deRegister();\n                            }\n                        }));\n                    }\n                }\n            });\n            this.listener = engine.registerListener({\n                canvasReady: () => {\n                    _.defer(() => {\n                        this.calculateRoutingMatrix();\n                        engine.repaintCanvas();\n                    });\n                }\n            });\n        }\n        setFactoryBank(bank) {\n            super.setFactoryBank(bank);\n            if (!bank && this.listener) {\n                this.listener.deregister();\n            }\n        }\n        generateReactWidget(event) {\n            return React.createElement(PathFindingLinkWidget_1.PathFindingLinkWidget, { diagramEngine: this.engine, link: event.model, factory: this });\n        }\n        generateModel(event) {\n            return new PathFindingLinkModel_1.PathFindingLinkModel();\n        }\n        /**\n         * A representation of the canvas in the following format:\n         *\n         * +-----------------+\n         * | 0 0 0 0 0 0 0 0 |\n         * | 0 0 0 0 0 0 0 0 |\n         * | 0 0 0 0 0 0 0 0 |\n         * | 0 0 0 0 0 0 0 0 |\n         * | 0 0 0 0 0 0 0 0 |\n         * +-----------------+\n         *\n         * In which all walkable points are marked by zeros.\n         * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n         */\n        getCanvasMatrix() {\n            if (this.canvasMatrix.length === 0) {\n                this.calculateCanvasMatrix();\n            }\n            return this.canvasMatrix;\n        }\n        calculateCanvasMatrix() {\n            const { width: canvasWidth, hAdjustmentFactor, height: canvasHeight, vAdjustmentFactor } = this.calculateMatrixDimensions();\n            this.hAdjustmentFactor = hAdjustmentFactor;\n            this.vAdjustmentFactor = vAdjustmentFactor;\n            const matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n            const matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n            this.canvasMatrix = _.range(0, matrixHeight).map(() => {\n                return new Array(matrixWidth).fill(0);\n            });\n        }\n        /**\n         * A representation of the canvas in the following format:\n         *\n         * +-----------------+\n         * | 0 0 1 1 0 0 0 0 |\n         * | 0 0 1 1 0 0 1 1 |\n         * | 0 0 0 0 0 0 1 1 |\n         * | 1 1 0 0 0 0 0 0 |\n         * | 1 1 0 0 0 0 0 0 |\n         * +-----------------+\n         *\n         * In which all points blocked by a node (and its ports) are\n         * marked as 1; points were there is nothing (ie, free) receive 0.\n         */\n        getRoutingMatrix() {\n            if (this.routingMatrix.length === 0) {\n                this.calculateRoutingMatrix();\n            }\n            return this.routingMatrix;\n        }\n        calculateRoutingMatrix() {\n            const matrix = _.cloneDeep(this.getCanvasMatrix());\n            // nodes need to be marked as blocked points\n            this.markNodes(matrix);\n            // same thing for ports\n            this.markPorts(matrix);\n            this.routingMatrix = matrix;\n        }\n        /**\n         * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n         * We use the functions below to translate back and forth between these coordinates, relying on the\n         * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n         */\n        translateRoutingX(x, reverse = false) {\n            return x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n        }\n        translateRoutingY(y, reverse = false) {\n            return y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n        }\n        generateDynamicPath(pathCoords) {\n            let path = Path();\n            path = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n            pathCoords.slice(1).forEach((coords) => {\n                path = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n            });\n            return path.print();\n        }\n    }\n    PathFindingLinkFactory.NAME = 'pathfinding';\n    return PathFindingLinkFactory;\n})();\nexports.PathFindingLinkFactory = PathFindingLinkFactory;\n//# sourceMappingURL=PathFindingLinkFactory.js.map"]},"metadata":{},"sourceType":"script"}